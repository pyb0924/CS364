.486
STRING_OUT MACRO INFO
	LEA 	DX,INFO
	MOV    AH, 09H
	INT    21H
ENDM
CHAR_OUT MACRO CHAR
	MOV DL,CHAR
    MOV AH,02H
	INT 21H
ENDM
OUTPUT MACRO INFO,DATA,NUM;USE: DX(info),DI(data),SI(numï¼‰
	LOCAL RES_OUTPUT
	STRING_OUT  INFO;output hint info
	MOV SI,NUM
	LEA DI,DATA	
	RES_OUTPUT:
	DATA_OUTPUT DI
	CHAR_OUT 20H
	ADD DI,4
	DEC SI
	CMP SI,0
	JNZ RES_OUTPUT
ENDM
DATA_OUTPUT MACRO YOURDATA
	LOCAL NUM_TO_STRING_PUSH
	LOCAL NUM_TO_STRING_POP
		MOV EAX,0
		MOV EDX,0
		MOV EAX,[YOURDATA]
		MOV SIGN,0
		MOV CX,0
		TEST EAX,80000000H
		JZ NUM_TO_STRING_PUSH
		; process negative num
		MOV SIGN,2DH
		NEG EAX	;change to unsigned num
	NUM_TO_STRING_PUSH:
		MOV EBX,10
		DIV EBX
		ADD DX,30H
		PUSH DX
		MOV DX,0
		INC CX; n-bit decimal
		CMP AX,0
		JNZ NUM_TO_STRING_PUSH
		MOV DL,SIGN
		CMP DL,0
		JZ NUM_TO_STRING_POP
		CHAR_OUT DL
	NUM_TO_STRING_POP:
		POP DX
		CHAR_OUT DL
		LOOP NUM_TO_STRING_POP
ENDM
SORT MACRO DATA,N
	LOCAL LP1
	LOCAL LP2
	LOCAL NEXT
	     MOV CX,N-1
	LP1: 
	     MOV    DI,CX
	     MOV    BX,0
	LP2: 
	     MOV    EAX,DATA[BX]
	     CMP    EAX,DATA[BX+4]
	     JGE    NEXT
	     XCHG   EAX,DATA[BX+4]
	     MOV    DATA[BX],EAX
	NEXT:
	     ADD    BX,4
	     DEC    DI
	     JNZ    LP2
	     LOOP   LP1
ENDM
JUMP_TABLE MACRO 
	STRING_OUT JUMP_INFO
	LEA BX,KEY
	MOV BYTE PTR[BX+1],0
	MOV BYTE PTR[BX+2],0
	; input to KEY
	LEA DX,KEY
	MOV AH,0AH
    INT 21H
	CHAR_OUT 0AH
	LEA DX,KEY
	MOV BX,DX
	ADD BX,2
	MOV AL,[BX]
	CMP AL,31H
	JZ FUNC1
	CMP AL,32H
	JZ FUNC2
	CMP AL,33H
	JZ FUNC3
	JMP MAIN_END
ENDM
STRING_INPUT MACRO BUF
		LEA DX,BUF
	    MOV AH,0AH
        INT 21H	
ENDM
INDEX_CHECK MACRO
	LOCAL JUMP_OUT
	LEA BX,INDEX
	MOV AL,[BX+1]
	CMP AL,0
	JNZ JUMP_OUT

	JMP MAIN_CHECK_ENDS
	JUMP_OUT:
	MOV AX,0
	MOV AL,[BX+2]
	CMP AL,30H
	JB KEY_WRONG
	SUB AL,30H
	MOV DL,N
	SUB DL,1
	CMP AL,DL
	JA KEY_WRONG

ENDM

SSEG SEGMENT USE16
	STK DW 20 DUP(?)
SSEG ENDS

DSEG SEGMENT USE16
	ORDER DD 10 DUP(?)
	DATA DD 10 DUP(?)
	N=10
	BUF DB 12
        DB ?
	    DB 12 DUP(?)
	FLAG DB 0
	SIGN DB ?
	CHECK_FLAG DB 0 
	NUM_OF_NEG DD 0
	FIRST_FLAG DB ? 
	SUM DD ?
	KEY DB 2
		DB ?
		DB 2 DUP(?)
	INDEX DB 2
		  DB ?
		  DB 2 DUP(?)
	INPUT_INFO DB 'Please input 10 numbers(-2147483647~2147483647)','$'
	INPUT_CHECK_INFO DB 'Please check your input: ','$'
	INPUT_INDEX_INFO1 DB 'Please input number ','$'
	INPUT_INDEX_INFO2 DB ': ','$'
	INDEX_INFO DB "Please input index[0~N-1] to modify data (input empty to continue): ",'$'
	INPUTEMPTY DB "INPUTERROR:Your input is empty! Please input again! ",'$'
	INPUTWRONG DB "INPUTERROR:You have input wrong characters! Please input again! ",'$'
	INDEXWRONG DB "Input out of index! Please input your index again! ",'$'
	INPUT_OF_INFO DB "ERROR:Overflowed!",'$'
	SUM_OF_INFO DB "ERROR:Sum Overflowed!",'$'
	NEW_INPUT DB "Your new input is: ",'$'
	JUMP_INFO DB 'Please choose your function(1,2,3). Input other characters to exit! ','$'
	NEG_COUNT_INFO DB 'The num of negative number is ','$'
	SUM_INFO DB 'The sum of your data is ','$' 
	OUTPUT_INFO DB 'The sorted data is: ','$'
	END_INFO DB 'The program ends! ','$'
DSEG   ENDS

CODE SEGMENT USE16
	     ASSUME CS:CODE,DS:DSEG,SS:SSEG
;input one data
DATA_INPUT PROC
		LEA BX,BUF
		MOV CX,0
        MOV CL,[BX+1]
        MOV AX,0
		MOV SIGN,0
        MOV AL,[BX+2]
        CMP AL,2DH
        JNZ STR_TO_NUM_PUSH
        ; negative process
        MOV SIGN,1
		
        INC BX
        DEC CL
        MOV [BX],CL
	STR_TO_NUM:
        MOV AL,[BX+2]
	STR_TO_NUM_PUSH:
        SUB AL,30H
        INC BX
        PUSH AX
        LOOP STR_TO_NUM

        LEA DI,BUF
        MOV CL,[DI+1]
		
        
        MOV EBX,0
        MOV DX,0
        MOV EDI,1 ;base
	STR_TO_NUM_POP:  
		MOV EAX,0
        POP AX
        MUL EDI
		JO INPUT_OVERFLOW
        ADD EBX,EAX
		
		CMP EBX,80000000H
		JAE INPUT_OVERFLOW
        MOV EAX,EDI
		SAL EAX,3
		SAL EDI,1
		ADD EDI,EAX
        LOOP STR_TO_NUM_POP

        MOV AL,SIGN
		CMP AL,0
        JZ STORE
        NEG EBX
	STORE:        
        MOV DS:[BP],EBX	
        RET
        ;DATA_OUTPUT DATA
	INPUT_OVERFLOW:
		SUB CL,1
	INPUT_OVERFLOW_LOOP:
		POP AX
		LOOP INPUT_OVERFLOW_LOOP
		STRING_OUT INPUT_OF_INFO
		INC SI
		SUB BP,4
		CHAR_OUT 0AH
		RET
ENDP
;judge input
INPUT_JUDGE PROC
	MOV FLAG,0 ; FLAG=0: correct input
	CALL INPUT_EMPTY
	CMP FLAG,1
	JNZ BEGIN_CHAR_JUDGE
	RET
	BEGIN_CHAR_JUDGE:
	CALL CHAR_JUDGE
	CHAR_OUT 0AH
	CMP FLAG,1
	JZ INPUT_WRONG_PROC
	RET
	INPUT_WRONG_PROC:
	STRING_OUT INPUTWRONG
	RET
INPUT_JUDGE ENDP

;judge wrong char
CHAR_JUDGE PROC
	LEA BX,BUF
	MOV CX,0
	MOV CL,[BX+1]
	ADD BX,1
	MOV FIRST_FLAG,0
	CHAR_JUDGE_LOOP:
	ADD BX,1
	CMP BYTE PTR[BX],30H
	JB WRONG
	CMP BYTE PTR[BX],39H
	JA WRONG
	MOV FIRST_FLAG,1
	LOOP CHAR_JUDGE_LOOP
	RET
	WRONG:
	MOV FLAG,1
	MOV AL,FIRST_FLAG
	CMP AL,0
	JZ FIRST_PROC
	RET
	FIRST_PROC:
	MOV FIRST_FLAG,1 ; first char (- special)
	CMP BYTE PTR[BX],2DH
	JZ FIRST_RIGHT
	RET
	FIRST_RIGHT:
	LEA DI,BUF ;special case: only input -
	CMP BYTE PTR[DI+1],1
	JZ ONLY_MINUS
	MOV FLAG,0
	LOOP CHAR_JUDGE_LOOP
	ONLY_MINUS:
	RET
CHAR_JUDGE ENDP

; judge if input is empty
INPUT_EMPTY PROC
	LEA BX,BUF
	MOV AL,[BX+1]
	CMP AL,0
	JNZ EMPTY_END
	CHAR_OUT 0AH
	STRING_OUT INPUTEMPTY
	MOV FLAG,1
	EMPTY_END:
	RET
INPUT_EMPTY ENDP

; total input 
INPUT PROC
	STRING_OUT INPUT_INFO
	CHAR_OUT 0AH
    LEA BP,DATA
    MOV SI,N
	INPUT_LOOP:
	STRING_OUT INPUT_INDEX_INFO1
	MOV AX,N
	SUB AX,SI
	ADD AL,30H
	CHAR_OUT AL
	STRING_OUT INPUT_INDEX_INFO2
    STRING_INPUT BUF
	CALL INPUT_JUDGE
	CMP FLAG,1
	JZ INPUT_LOOP
	
    CALL DATA_INPUT
OF1:
    ADD BP,4
    DEC SI
    CMP SI,0
    JNZ INPUT_LOOP

    RET
INPUT ENDP

; move from data to order
DATA_MOVE PROC
	LEA SI,DATA
	LEA DI,ORDER
	MOV CX,N
	MOVE_LOOP:
	MOV EAX,[SI]
	MOV [DI],EAX
	ADD SI,4
	ADD DI,4
	LOOP MOVE_LOOP
	RET
DATA_MOVE ENDP

; func1: count negative number
NEG_COUNT PROC
	STRING_OUT NEG_COUNT_INFO
	LEA BX,DATA
	MOV CX,N
	MOV EDX,0
	NEG_COUNT_LOOP:
	MOV EAX,[BX]
	ADD BX,4
	CMP EAX,0
	JGE	NEG_COUNT_LOOP_END
	INC EDX
	NEG_COUNT_LOOP_END:
	LOOP NEG_COUNT_LOOP

	MOV NUM_OF_NEG,EDX
	LEA DI,NUM_OF_NEG

	DATA_OUTPUT DI
	RET
NEG_COUNT ENDP

; func2: get sum
GETSUM PROC
	STRING_OUT SUM_INFO
	LEA BX,DATA
	MOV EAX,0
	MOV EDX,0
	MOV CX,N
	SUM_LOOP:
	MOV EDX,[BX]
	ADD EAX,EDX
	JO OVERFLOW
	ADD BX,4
	LOOP SUM_LOOP

	MOV SUM,EAX
	LEA DI,SUM
	DATA_OUTPUT DI
	RET
	OVERFLOW:
	STRING_OUT SUM_OF_INFO
	RET

GETSUM ENDP

; check input (index,new input)
INPUT_CHECK PROC
	STRING_OUT INDEX_INFO
	INPUT_CHECK_START:
	
	STRING_INPUT INDEX
	INDEX_CHECK
	
	REINPUT_START:
	CHAR_OUT 0AH
	STRING_OUT NEW_INPUT
	STRING_INPUT BUF
	CALL INPUT_JUDGE
	;CHAR_OUT 0AH
	CMP FLAG,1
	JZ REINPUT_START

	LEA BX,INDEX
	MOVZX AX,[BX+2]
	SUB AL,30H
	SAL AL,2
	LEA BP,DATA
	ADD BP,AX
	CALL DATA_INPUT
	INPUT_CHECK_RET:
	RET

KEY_WRONG:
	CHAR_OUT 0AH
	STRING_OUT INDEXWRONG
	JMP INPUT_CHECK_START


INPUT_CHECK ENDP

PUBLIC MAIN2
MAIN2 PROC FAR
	MOV    AX,DSEG
	MOV    DS,AX
	CALL INPUT
    ; \n
    CHAR_OUT 0AH
	; check input
MAIN_INPUT_CHECK:
	OUTPUT INPUT_CHECK_INFO,DATA,N
	CHAR_OUT 0AH
	CALL INPUT_CHECK
	CHAR_OUT 0AH
	;CMP CHECK_FLAG,0
	JMP MAIN_INPUT_CHECK

MAIN_CHECK_ENDS:
	POP AX

JUMP:
	; \n	
	CHAR_OUT 0AH
	JUMP_TABLE
	
FUNC1:	
	; count negative number
	CALL NEG_COUNT
    CHAR_OUT 0AH
	JMP JUMP

FUNC2:
	; calculate sum
	CALL GETSUM
	; \n
	CHAR_OUT 0AH
	JMP JUMP

FUNC3:
	CALL DATA_MOVE
	; sort	
	SORT ORDER,N
	; output result
	OUTPUT OUTPUT_INFO,ORDER,N
	CHAR_OUT 0AH
	JMP JUMP

MAIN_END:
	STRING_OUT END_INFO
	
	RET
MAIN2 ENDP
CODE   ENDS
       END  MAIN2